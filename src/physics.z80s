	include "tile_properties.z80s"

ds align 256
DrawTile_LookupT:
J: equ FOR 12
 I: equ FOR 16
 	dw DRAWtiles.png_{I}_{J}
 	db DRAWtiles.png_{I}_{J}PAGE | 32
 	db tile_properties_{I+(16*J)}
 NEXT I
NEXT J



    

BEGIN_SCREEN:	
print "BEGIN_SCREEN", $
				; hl points to level map data

                ld sp, HMEM_STACK_FRAME

				ld de, 0
				ld (FRAMEVECTOR),de


				ld a,BORDERSCREENOFF
				out (border),a

				ei
					
				
				ld a,(hl)
				inc l
				ld (current_level_width),a
				ld a,(hl)
				inc l
; there's less of a case that this is useful				ld (current_level_height),a
				ld e,(hl)
				inc l
				ld d,(hl)
				inc l
				ld (current_level_offset),de

				ld a,(hl)
				inc l
				ld (PLAYER_SPACE + PLAYER.y),a
				ld a,(hl)
				inc l
				ld (PLAYER_SPACE + PLAYER.x),a
				xor a
				ld (PLAYER_SPACE + PLAYER.yl),a
				ld (PLAYER_SPACE + PLAYER.xl),a

SWITCH_SCREEN_THREAD: print "SWITCH_SCREEN_THREAD",$

				xor a
				ld (NEXTDISPLAYSCREEN),a
				
				ld ix, drawtiles_loopreturn


current_level_offset: equ $+1
				ld hl,(0000)
							

				ld e,3
tiledraw_loop_buffer:
				ld a,e
				dec a
				rla
				add SCREENPAGE0
				out (hmpr),a

				ld bc,0
                ld (65534),bc

				exx
				ld hl,32768
				exx
				ld c,11
tiledraw_loop_y:				

				ld b,16
tiledraw_loop_x:				
				ld a,(hl)
				
				
				exx
				
				ld c,a
				xor a
				rl c
				rla
				rl c
				rla
				add DrawTile_LookupT/256
				ld b,a
				
				ld a,(bc)
				ld e,a
				inc c
				ld a,(bc)
				ld d,a
				inc c
				ld a,(bc)
				
				jp HMEM_SWITCH_LMEM_DRAW  ; SP is background remove stack, DE is routine in page A, HL is HMEM address to draw			
drawtiles_loopreturn:
				ld a,l
				sub 128-8
				ld l,a
				exx
				inc hl
				djnz tiledraw_loop_x
				
				exx
				ld l,0
				ld a,h
				add 8
				ld h,a
				exx
				dec c
				jr nz, tiledraw_loop_y

				ld a,l
				sub 16*11
				ld l,a
				ld a,h
				sbc 0
				ld h,a

				dec e
				jr nz, tiledraw_loop_buffer		

			  ; draw the whole screen three times
              ; don't call DUPLICATESCREENDATA, it disables interrupts (and has long LDIRs anyway) which will disrupt music
                
                
                
                
                
; then loop again to fill in the physics tables
; (shame not to put this in the other loop, but we don't need to execute it three times)                
                
                ld de, BLOCK_COLLISION_TABLE
                
                exx
                ld b, 16*11
setup_COLLISION_TABLE_loop:
                exx
                
 				ld c,(hl)
 				inc hl
				xor a
				scf
				rl c
				rla
				scf
				rl c
				rla
				add DrawTile_LookupT/256
				ld b,a
               
                ld a,(bc)
                ld (de),a
                inc e
                
                exx
                djnz setup_COLLISION_TABLE_loop
                
                
                
                
                
                
CLEAR_OBJECT_GROUPS:
				ld hl, OBJECTS_GROUP0
		@loop2:
				ld (hl),l ;0
				inc l
				ld (hl),2
				inc l
				ld a,l
		@loop1:
				ld l,a
				add OBJECT.SIZEOF
				ld (hl), a
				cp 256-OBJECT.SIZEOF
				jr c, @loop1
				xor a
				ld (hl),a
				ld l,a
				ld a,h
				add 2
				ld h,a
				cp 	OBJECTS_GROUP2/256 +2
				jr c, @loop2
                
                
                
                
                
                
				ld hl, GAMEPHYSICS_INTCALLBACK
				ld (FRAMEVECTOR),hl

				ld a,SCREENPAGE0
				out (hmpr),a

				ld a,BORDERSCREENON
				out (border),a

				ei

                jp MAINLOOP


HORIZONTAL_IMPULSE: equ 400
VERTICAL_IMPULSE:   equ 900
GRAVITY_IMPULSE:	equ 300

SHIP_HEIGHT: equ 16
SHIP_WIDTH: equ 24

GAMEPHYSICS_INTCALLBACK:
				ld a,(last_calculated_frame)
				inc a
				ld (last_calculated_frame),a    ; signal that we want the screen frame to update + cycle


				

				ld IX, PLAYER_SPACE

				ld l,(IX+ PLAYER.xspeed)
				ld h,(IX+ PLAYER.xspeedh)


				ld d, KEYBOARD_TABLE/256
				ld e, (IX + PLAYER.LEFT_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.LEFT_KEYmask)
				jr nz, no_left_impulse
				
				ld bc, - HORIZONTAL_IMPULSE
				add hl,bc

no_left_impulse:

				ld e, (IX + PLAYER.RIGHT_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.RIGHT_KEYmask)
				jr nz, no_right_impulse
				
				ld bc, HORIZONTAL_IMPULSE
				add hl,bc
			
no_right_impulse:

							; dampening
				sra h
				rr l
					
				
				ld (IX+ PLAYER.xspeed),l
				ld (IX+ PLAYER.xspeedh),h
				
				ld b,h

				ld e,(IX+ PLAYER.xl)
				ld d,(IX+ PLAYER.x)
				
				add hl,de
				
				set 0,l	; this is a bit of a hack - after moving left, divisions can never reduce speed below -1.
						; this is a fairly insignificant reduction in precision, but stops us drifting to the left 1 pixel every 5 seconds











				ld a,h
				
				bit 7,b
				jr nz, check_blocked_left
				
				add SHIP_WIDTH-1
				jp c, switch_screen_right
				jr @+
check_blocked_left:
				cp 240
				jp nc, switch_screen_left
	@:
				rra
				rra
				rra
				rra
				and 0x0f
				ld e,a
				
				ld a,(IX+ PLAYER.y)
				ld c,a
				and 0xf0
				or e
				ld e,a
				ld d, BLOCK_COLLISION_TABLE/256
								
				ld  a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_horizontal
								
				ld a,c
				dec a
				and 0x0f
				inc a
				sub SHIP_HEIGHT
				jr nc, not_blocked_horizontal
				
				ld a,e
				add 16
				ld e,a


				ld a,(de)
				and  TILE_COLLIDES
				jr z,not_blocked_horizontal

blocked_horizontal:
print $
				; special case, if the player is trying to enter a tunnel exactly one block high
				; (which is the same height as some ships, so we can skip over it if not pixel aligned)
				
				ld a,e
				and 0x0f
				ld e,a

				bit 7, (IX+ PLAYER.yspeedh)
				jr nz, specialcase_goingup

				ld a,c
				and 0x0f
				cp 14
				jr c, specialcase_notapplicable

				ld a,c
				and 0xf0
				add 0x10
				or e
				ld e,a
				
				ld a,(de)
				and  TILE_COLLIDES
				jr nz,specialcase_notapplicable
				
				ld a,e
				add 0x10
				ld e,a
				ld a,(de)
				and TILE_COLLIDES
				jr z,specialcase_notapplicable
				
				ld a,e
				sub 0x10
				and 0xf0
				ld (IX+ PLAYER.y),a
				jr not_blocked_horizontal

specialcase_goingup:

				ld a,c
				and 0x0f
				cp 3
				jr nc, specialcase_notapplicable

				ld a,c
				and 0xf0
				or e
				ld e,a
				
				ld a,(de)
				and  TILE_COLLIDES
				jr  nz,specialcase_notapplicable

				ld a,e
				sub 0x10
				ld e,a
				ld a,(de)
				and TILE_COLLIDES
				jr z,specialcase_notapplicable

				ld a,e
				add 0x10
				and 0xf0
				ld (IX+ PLAYER.y),a
				jr not_blocked_horizontal

specialcase_notapplicable:
				ld a,e
				rla
				rla
				rla
				rla
				and 0xf0
				
				bit 7,b
				jr nz, blocked_left
				sub SHIP_WIDTH
				jr set_ship_horizontal_position
blocked_left:
				add 16
set_ship_horizontal_position: 
				ld h,a
				ld l,1



not_blocked_horizontal:
				
				ld (IX+ PLAYER.xl),l
				ld (IX+ PLAYER.x),h




				ld l,(IX+ PLAYER.yspeed)
				ld h,(IX+ PLAYER.yspeedh)

				ld d, KEYBOARD_TABLE/256
				ld e, (IX + PLAYER.UP_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.UP_KEYmask)
				jr nz, no_vertical_impulse
				
				ld bc, - VERTICAL_IMPULSE
				add hl,bc

no_vertical_impulse:

				ld bc, GRAVITY_IMPULSE
				add hl,bc
				
							; dampening
				sra h
				rr l

				ld (IX+ PLAYER.yspeed),l
				ld (IX+ PLAYER.yspeedh),h

				ld b,h

				ld e,(IX+ PLAYER.yl)
				ld d,(IX+ PLAYER.y)
				
				add hl,de
				
				ld a,h
				
				bit 7,b
				jr nz, check_blocked_upwards
				
				add SHIP_HEIGHT-1
				cp 176
				jp nc, switch_screen_down
				jr @+
				
check_blocked_upwards:
				cp 192
				jp nc, switch_screen_up
	@:
				and 0xf0
				ld e,a
				
				ld a,(IX+ PLAYER.x)
				ld c,a
				rra
				rra
				rra
				rra
				and 0x0f
				or e
				ld e,a
				ld d, BLOCK_COLLISION_TABLE/256
				
				
				ld  a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_vertical
				
				inc e


				ld a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_vertical
				
				ld a,c
				and 0x0f
				sub SHIP_WIDTH-15
				jr c, not_blocked_vertical
				
				inc e


				ld a,(de)
				and  TILE_COLLIDES
				jr z,not_blocked_vertical

blocked_vertical:
				ld a,e
				and 0xf0
				bit 7,b
				jr nz, blocked_above
				sub SHIP_HEIGHT
				jr set_ship_vertical_position
blocked_above:
				add 16
set_ship_vertical_position: 
				ld h,a
				ld l,1
not_blocked_vertical:




				ld a,h			; emergency screen safety
				cp 176
				jr c, +@
				ld h,176
				@:
				ld (IX+ PLAYER.yl),l
				ld (IX+ PLAYER.y),h





; launch projectiles if the player is firing

				ld h, (IX + PLAYER.oneshot)

				ld d, KEYBOARD_TABLE/256
				ld e, (IX + PLAYER.FIRE_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.FIRE_KEYmask)

				ld (IX + PLAYER.oneshot),a
				xor h
				and h
				jp z, no_new_firing
		


				ld a,(IX + PLAYER.y)
				add SHIP_HEIGHT-3
				ld h,a
				ld a,(IX + PLAYER.x)
				add SHIP_WIDTH - lasershot.png_0.WIDTH
				ld l,a
				
				
				ld de, LASER_TEMPLATE_R
				bit 7,(IX + PLAYER.xspeedh)
				jr z,@
				ld de, LASER_TEMPLATE_L
@:				ld a, OBJECTS_GROUP1/256
				call ADD_OBJECT


no_new_firing:















			; 	walk all the lists and call their frame vectors
				ld IY,OBJECTS_GROUP0
@call_objects_group_loop:
				xor a
				ld (@object_last_link_pointer),a
			
				ld a,(IY+LIST.HEADPTR)
				
				or a
				jr z,@empty_list
@call_objects_loop:				
				ld IYl,a
				ld l,(IY+6)
				ld h,(IY+7)
				ld a,l
				or h
				jr z, @objects_next				
				ld bc, @objects_return
				push bc
				jp (hl)
@objects_return:
				; carry flag set - remove this object from the list

		@object_last_link_pointer: equ $+1
				ld a,00
				call c, REMOVE_OBJECT
				
@objects_next:				
				ld a,IYl
				ld (@object_last_link_pointer),a
				
				ld a,(IY+0)
				or a
				jr nz, @call_objects_loop
@empty_list:
				ld a,IYh
				add 2
				ld IYh,a
				cp OBJECTS_GROUP2/256 + 2
				jr nz, @call_objects_group_loop





; this is a cheat and should become an object in group 1. 
; If it is the first added, it will always be at the back of the list and will have the correct drawing order.
			; draw ship (last, so it appears above laser shots being fired etc)
				ld e, (IX + PLAYER.x)
				ld d, (IX + PLAYER.y)
				
				bit 7,(IX + PLAYER.xspeedh)
				jr nz, ship_pointing_left
				ld bc, ship.png_0_0ID
				jr +@
ship_pointing_left:
				ld bc, ship.png_1_0ID
@:
				call ADD_SPRITE_TO_CURRENT_LIST ; bc=routine, de=location (uses HL)


				ret

PROJECTILE_OBJECT.DRAWING_IDl : equ 0
PROJECTILE_OBJECT.DRAWING_IDh : equ 1
PROJECTILE_OBJECT.XSPEEDl : 	equ 2
PROJECTILE_OBJECT.XSPEED: 		equ 3
PROJECTILE_OBJECT.YSPEEDl : 	equ 4
PROJECTILE_OBJECT.YSPEED: 		equ 5
PROJECTILE_OBJECT.XOFFSET : 	equ 6
PROJECTILE_OBJECT.YOFFSET: 		equ 7
PROJECTILE_OBJECT.Xl : 			equ 8
PROJECTILE_OBJECT.Yl: 			equ 9




LASER_TEMPLATE_R:	db 0, lasershot.png_0.HEIGHT, lasershot.png_0.WIDTH
					dw PROJECTILE_OBJECT_FRAME, 0
					dw lasershot.png_0ID, 7*256,0,0,0
LASER_TEMPLATE_L:	db 0, lasershot.png_0.HEIGHT, lasershot.png_0.WIDTH
					dw PROJECTILE_OBJECT_FRAME, 0
					dw lasershot.png_1ID, -7*256,0,0,0

PROJECTILE_OBJECT_FRAME:		
				ld e,(IY + OBJECT.X)
				ld d,(IY + OBJECT.Y)
				INC IYh
				
				ld a,(IY + PROJECTILE_OBJECT.Xl)
				add (IY + PROJECTILE_OBJECT.XSPEEDl)
				ld (IY + PROJECTILE_OBJECT.Xl),a
				
				ld a,e
				ld b, (IY + PROJECTILE_OBJECT.XSPEED)
				adc b
				bit 7,b
				jr z, @
				ccf
	@:			jr c,@remove
				ld e,a


				ld a,(IY + PROJECTILE_OBJECT.Yl)
				add (IY + PROJECTILE_OBJECT.YSPEEDl)
				ld (IY + PROJECTILE_OBJECT.Yl),a
				
				ld a,d
				adc (IY + PROJECTILE_OBJECT.YSPEED)
				jr c,@remove
				ld d,a


				ld l,(IY + PROJECTILE_OBJECT.XOFFSET)
				ld h,(IY + PROJECTILE_OBJECT.YOFFSET)
				ld c,(IY+0)
				ld b,(IY+1)
				DEC IYh

				ld (IY + OBJECT.X),e
				ld (IY + OBJECT.Y),d
				
				ld a,e
				sub l
				ld e,a
				ld a,d
				sub l
				ld d,a				

				or a
				jp ADD_SPRITE_TO_CURRENT_LIST
@remove:
				dec IYh
				scf
				ret




switch_screen_down:
				
				ld hl,(current_level_offset)
				
current_level_width: equ $+1
				ld a,0
				add a
				add l
				ld l,a
				ld (current_level_offset),hl
				
				xor a
				ld (IX + PLAYER.y),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret
                
switch_screen_up:
				
				ld hl,(current_level_offset)
				
				ld a,(current_level_width)
				add a
				neg
				add l
				ld l,a
				ld (current_level_offset),hl
				
				ld a,176-SHIP_HEIGHT
				ld (IX + PLAYER.y),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret
 
switch_screen_left:
				
				ld hl,(current_level_offset)
				dec l
				dec l
				ld (current_level_offset),hl
				
				ld a,-SHIP_WIDTH
				ld (IX + PLAYER.x),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret
 
switch_screen_right:
				
				ld hl,(current_level_offset)
				inc l
				inc l
				ld (current_level_offset),hl
				
				xor a
				ld (IX + PLAYER.x),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret





ADD_OBJECT:		; add object template from DE into object group A; HL goes into object X/Y fields, 
				; returns object in hl (or l=0, carry set if the list is full)
				
				push hl
				
				ld h,a
				ld l,0
				ld b,(hl)	; head pointer
				inc l
				ld c,(hl)	; free pointer
				dec l
				
				ld a,c
				or a
				jr z, object_list_is_full
				
				ld (hl),c
				
				ld l,c
				ld a,(hl)
				ld l,1
				ld (hl),a
				
				ld l,c
				ld (hl),b	; new object link
				
				inc l
				ld a,(de)
				ld (hl),a

				inc l
				inc de
				
				ld a,c		; pointer to object start low byte
				
				pop bc
				ld (hl),c
				inc l
				ld (hl),b
				inc l
				
				ex de,hl
				
				for 6, LDI
											
				inc d
				ld e,a
				
				for 10, LDI
				
				ld h,d
				dec h
				ld l,a
				
				ret
				
object_list_is_full:	
				pop bc
				scf
				ret

print "REMOVE_OBJECT", $
REMOVE_OBJECT:			; remove the list object pointed to by IY, A is the previous link pointing to this object
						; IY is left pointing at the previous object (or IYl=0, the list head)

				ld c,IYl			; this object
				ld d,(IY + 0)		; next object
				
				; put this object at the head of the free list
				ld b,IYh
				ld h,b
				ld l,1
				ld e,(HL)
				ld (HL),c
				ld (IY + 0),e		

				; close the gap in the allocated objects list
				ld IYl,a
				ld (IY + 0), d
				
				ret



best_level: db 0





PLAYER.Xl: equ 0
PLAYER.X: equ 1
PLAYER.Yl: equ 2
PLAYER.y: equ 3
PLAYER.xspeed: equ 4
PLAYER.xspeedh: equ 5
PLAYER.yspeed: equ 6
PLAYER.yspeedh: equ 7

PLAYER.oneshot: equ 8

player.next_extend0: equ 32	; 0
player.next_extend1: equ 33	; 10(00)(0)
player.next_extend2: equ 34
player.next_extend3: equ 35
player.next_extendEND: equ 36

PLAYER.SCORE0: equ 40       ; binary coded decimal omitting an implied extra zero
PLAYER.SCORE1: equ 41
PLAYER.SCORE2: equ 42
PLAYER.SCORE3: equ 43
PLAYER.SCOREEND: equ 44       ; space for a 255 end marker after 8 digits of content


PLAYER.UP_KEYMASK:  equ 54
PLAYER.UP_KEYADDR:  equ 55
PLAYER.DOWN_KEYMASK:equ 56
PLAYER.DOWN_KEYADDR:equ 57
PLAYER.LEFT_KEYMASK:equ 58
PLAYER.LEFT_KEYADDR:equ 59
PLAYER.RIGHT_KEYMASK:equ 60
PLAYER.RIGHT_KEYADDR:equ 61
PLAYER.FIRE_KEYMASK:equ 62
PLAYER.FIRE_KEYADDR:equ 63


; keeps separate lists of things that don't need to interact with each other to minimize walking time
; i.e. explosions and other graphical touches don't need to interact with anything
; suggest groups:
; 1 - player, player's laser fire
; 2 - enemy ships, enemy bullets
; 3 - bounty and powerups

; list of 1 walks the list of 2			(N squared!)
; player (only) walks the list of 3

; there is some opportunity to be clever and minimize the work done in the 1 - 2 interaction
; e.g. by keeping the lists sorted or partitioned.
; It's not entirely clear that this will be a gain overall considering maintenance overhead

; It will help if all the objects (at least, within a group) have some consistent formatting
; (there doesn't seem to be a requirement for the size to be power-of-2)

OBJECT.LINK:  equ 0 ; 0 link
OBJECT.ID:    equ 1 ; 1 ID? (Perhaps this is implicit from one of the vectors)
OBJECT.X:     equ 2 ; 2-3 Y/X
OBJECT.Y:     equ 3
OBJECT.W:     equ 4 ; 4-5 H/W
OBJECT.H:     equ 5
OBJECT.FRAME: equ 6 ; 6-7 call every frame   IY=this (return: carry set = remove this item)
OBJECT.HIT:   equ 8 ; 8-9 call on collision  IY=this, IX=that (return: carry set = remove that item and stop walking this list)
OBJECT.SIZEOF: equ 10
; Could keep IMP DEF data by increasing the size of the record
; - either decreases the number of items in the list
; - or makes walking slower if link contains 2 bytes or is encoded
; - or keep imp def in a parallel list at +256               <= try this one for now
; e.g. inc IYh; ld a,(IY+0); dec IYh

			ds align 256
OBJECTS_GROUP0: ds 512 ; head link at 0, free link at 1 [0 means NULL]. Up to 25 objects of 10 bytes each
OBJECTS_GROUP1: ds 512 ;
OBJECTS_GROUP2: ds 512 ;

LIST.HEADPTR: equ 0
LIST.FREEPTR: equ 1

SIZEOF.PLAYER: equ 64

                ds align 128
PLAYER_SPACE:	ds 2*SIZEOF.PLAYER
PLAYER2_SPACE: equ PLAYER_SPACE+SIZEOF.PLAYER
