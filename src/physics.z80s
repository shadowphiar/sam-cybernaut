	include "tile_properties.z80s"

ds align 256
DrawTile_LookupT:
J: equ FOR 12
 I: equ FOR 16
 	dw DRAWtiles.png_{I}_{J}
 	db DRAWtiles.png_{I}_{J}PAGE | 32
 	db tile_properties_{I+(16*J)}
 NEXT I
NEXT J



    

BEGIN_SCREEN:	
print "BEGIN_SCREEN", $
				; hl points to level map data

                ld sp, HMEM_STACK_FRAME

				ld de, 0
				ld (FRAMEVECTOR),de


				ld a,BORDERSCREENOFF
				out (border),a

				ei
					
				
				ld a,(hl)
				inc l
				ld (current_level_width),a
				ld a,(hl)
				inc l
; there's less of a case that this is useful				ld (current_level_height),a
				ld e,(hl)
				inc l
				ld d,(hl)
				inc l
				ld (current_level_offset),de

				ld a,(hl)
				inc l
				ld (PLAYER_SPACE + PLAYER.y),a
				ld a,(hl)
				inc l
				ld (PLAYER_SPACE + PLAYER.x),a
				xor a
				ld (PLAYER_SPACE + PLAYER.yl),a
				ld (PLAYER_SPACE + PLAYER.xl),a

SWITCH_SCREEN_THREAD: print "SWITCH_SCREEN_THREAD",$

				xor a
				ld (NEXTDISPLAYSCREEN),a
				
				ld ix, drawtiles_loopreturn


current_level_offset: equ $+1
				ld hl,(0000)
							

				ld e,3
tiledraw_loop_buffer:
				ld a,e
				dec a
				rla
				add SCREENPAGE0
				out (hmpr),a

				ld bc,0
                ld (65534),bc

				exx
				ld hl,32768
				exx
				ld c,11
tiledraw_loop_y:				

				ld b,16
tiledraw_loop_x:				
				ld a,(hl)
				
				
				exx
				
				ld c,a
				xor a
				rl c
				rla
				rl c
				rla
				add DrawTile_LookupT/256
				ld b,a
				
				ld a,(bc)
				ld e,a
				inc c
				ld a,(bc)
				ld d,a
				inc c
				ld a,(bc)
				
				jp HMEM_SWITCH_LMEM_DRAW  ; SP is background remove stack, DE is routine in page A, HL is HMEM address to draw			
drawtiles_loopreturn:
				ld a,l
				sub 128-8
				ld l,a
				exx
				inc hl
				djnz tiledraw_loop_x
				
				exx
				ld l,0
				ld a,h
				add 8
				ld h,a
				exx
				dec c
				jr nz, tiledraw_loop_y

				ld a,l
				sub 16*11
				ld l,a
				ld a,h
				sbc 0
				ld h,a

				dec e
				jr nz, tiledraw_loop_buffer		

			  ; draw the whole screen three times
              ; don't call DUPLICATESCREENDATA, it disables interrupts (and has long LDIRs anyway) which will disrupt music
                
                
                
                
                
; then loop again to fill in the physics tables
; (shame not to put this in the other loop, but we don't need to execute it three times)                
                
                ld de, BLOCK_COLLISION_TABLE
                
                exx
                ld b, 16*11
setup_COLLISION_TABLE_loop:
                exx
                
 				ld c,(hl)
 				inc hl
				xor a
				scf
				rl c
				rla
				scf
				rl c
				rla
				add DrawTile_LookupT/256
				ld b,a
               
                ld a,(bc)
                ld (de),a
                inc e
                
                exx
                djnz setup_COLLISION_TABLE_loop
                
                
                
                
                
                
                
                
				ld hl, GAMEPHYSICS_INTCALLBACK
				ld (FRAMEVECTOR),hl

				ld a,SCREENPAGE0
				out (hmpr),a

				ld a,BORDERSCREENON
				out (border),a

				ei

                jp MAINLOOP


HORIZONTAL_IMPULSE: equ 400
VERTICAL_IMPULSE:   equ 900
GRAVITY_IMPULSE:	equ 300

SHIP_HEIGHT: equ 16
SHIP_WIDTH: equ 24

GAMEPHYSICS_INTCALLBACK:
				ld a,(last_calculated_frame)
				inc a
				ld (last_calculated_frame),a    ; signal that we want the screen frame to update + cycle


				

				ld IX, PLAYER_SPACE

				ld l,(IX+ PLAYER.xspeed)
				ld h,(IX+ PLAYER.xspeedh)


				ld d, KEYBOARD_TABLE/256
				ld e, (IX + PLAYER.LEFT_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.LEFT_KEYmask)
				jr nz, no_left_impulse
				
				ld bc, - HORIZONTAL_IMPULSE
				add hl,bc

no_left_impulse:

				ld e, (IX + PLAYER.RIGHT_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.RIGHT_KEYmask)
				jr nz, no_right_impulse
				
				ld bc, HORIZONTAL_IMPULSE
				add hl,bc
			
no_right_impulse:

							; dampening
				sra h
				rr l
					
				
				ld (IX+ PLAYER.xspeed),l
				ld (IX+ PLAYER.xspeedh),h
				
				ld b,h

				ld e,(IX+ PLAYER.xl)
				ld d,(IX+ PLAYER.x)
				
				add hl,de
				
				set 0,l	; this is a bit of a hack - after moving left, divisions can never reduce speed below -1.
						; this is a fairly insignificant reduction in precision, but stops us drifting to the left 1 pixel every 5 seconds











				ld a,h
				
				bit 7,b
				jr nz, check_blocked_left
				
				add SHIP_WIDTH-1
				jp c, switch_screen_right
				jr @+
check_blocked_left:
				cp 240
				jp nc, switch_screen_left
	@:
				rra
				rra
				rra
				rra
				and 0x0f
				ld e,a
				
				ld a,(IX+ PLAYER.y)
				ld c,a
				and 0xf0
				or e
				ld e,a
				ld d, BLOCK_COLLISION_TABLE/256
								
				ld  a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_horizontal
								
				ld a,c
				dec a
				and 0x0f
				inc a
				sub SHIP_HEIGHT
				jr nc, not_blocked_horizontal
				
				ld a,e
				add 16
				ld e,a


				ld a,(de)
				and  TILE_COLLIDES
				jr z,not_blocked_horizontal

blocked_horizontal:
print $
				ld a,e
				rla
				rla
				rla
				rla
				and 0xf0
				
				bit 7,b
				jr nz, blocked_left
				sub SHIP_WIDTH
				jr set_ship_horizontal_position
blocked_left:
				add 16
set_ship_horizontal_position: 
				ld h,a
				ld l,1



not_blocked_horizontal:
				
				ld (IX+ PLAYER.xl),l
				ld (IX+ PLAYER.x),h




				ld l,(IX+ PLAYER.yspeed)
				ld h,(IX+ PLAYER.yspeedh)

				ld d, KEYBOARD_TABLE/256
				ld e, (IX + PLAYER.UP_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.UP_KEYmask)
				jr nz, no_vertical_impulse
				
				ld bc, - VERTICAL_IMPULSE
				add hl,bc

no_vertical_impulse:

				ld bc, GRAVITY_IMPULSE
				add hl,bc
				
							; dampening
				sra h
				rr l

				ld (IX+ PLAYER.yspeed),l
				ld (IX+ PLAYER.yspeedh),h

				ld b,h

				ld e,(IX+ PLAYER.yl)
				ld d,(IX+ PLAYER.y)
				
				add hl,de
				
				ld a,h
				
				bit 7,b
				jr nz, check_blocked_upwards
				
				add SHIP_HEIGHT-1
				cp 176
				jp nc, switch_screen_down
				jr @+
				
check_blocked_upwards:
				cp 192
				jr nc, switch_screen_up
	@:
				and 0xf0
				ld e,a
				
				ld a,(IX+ PLAYER.x)
				ld c,a
				rra
				rra
				rra
				rra
				and 0x0f
				or e
				ld e,a
				ld d, BLOCK_COLLISION_TABLE/256
				
				
				ld  a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_vertical
				
				inc e


				ld a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_vertical
				
				ld a,c
				and 0x0f
				sub SHIP_WIDTH-15
				jr c, not_blocked_vertical
				
				inc e


				ld a,(de)
				and  TILE_COLLIDES
				jr z,not_blocked_vertical

blocked_vertical:
				ld a,e
				and 0xf0
				bit 7,b
				jr nz, blocked_above
				sub SHIP_HEIGHT
				jr set_ship_vertical_position
blocked_above:
				add 16
set_ship_vertical_position: 
				ld h,a
				ld l,1
not_blocked_vertical:




				ld a,h			; emergency screen safety
				cp 176
				jr c, +@
				ld h,176
				@:
				ld (IX+ PLAYER.yl),l
				ld (IX+ PLAYER.y),h







				
				ld e, (IX + PLAYER.x)
				ld d, (IX + PLAYER.y)
				
				bit 7,(IX + PLAYER.xspeedh)
				jr nz, ship_pointing_left
				ld bc, ship.png_0_0ID
				jr +@
ship_pointing_left:
				ld bc, ship.png_1_0ID
@:
				call ADD_SPRITE_TO_CURRENT_LIST ; bc=routine, de=location (uses HL)


				ret






switch_screen_down:
				
				ld hl,(current_level_offset)
				
current_level_width: equ $+1
				ld a,0
				add a
				add l
				ld l,a
				ld (current_level_offset),hl
				
				xor a
				ld (IX + PLAYER.y),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret
                
switch_screen_up:
				
				ld hl,(current_level_offset)
				
				ld a,(current_level_width)
				add a
				neg
				add l
				ld l,a
				ld (current_level_offset),hl
				
				ld a,176-SHIP_HEIGHT
				ld (IX + PLAYER.y),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret
 
switch_screen_left:
				
				ld hl,(current_level_offset)
				dec l
				dec l
				ld (current_level_offset),hl
				
				ld a,-SHIP_WIDTH
				ld (IX + PLAYER.x),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret
 
switch_screen_right:
				
				ld hl,(current_level_offset)
				inc l
				inc l
				ld (current_level_offset),hl
				
				xor a
				ld (IX + PLAYER.x),a

				ld hl, SWITCH_SCREEN_THREAD
				ld (EXIT_MAIN_LOOP_VECTOR), hl
                ret


best_level: db 0





PLAYER.Xl: equ 0
PLAYER.X: equ 1
PLAYER.Yl: equ 2
PLAYER.y: equ 3
PLAYER.xspeed: equ 4
PLAYER.xspeedh: equ 5
PLAYER.yspeed: equ 6
player.yspeedh: equ 7


player.next_extend0: equ 32	; 0
player.next_extend1: equ 33	; 10(00)(0)
player.next_extend2: equ 34
player.next_extend3: equ 35
player.next_extendEND: equ 36

PLAYER.SCORE0: equ 40       ; binary coded decimal omitting an implied extra zero
PLAYER.SCORE1: equ 41
PLAYER.SCORE2: equ 42
PLAYER.SCORE3: equ 43
PLAYER.SCOREEND: equ 44       ; space for a 255 end marker after 8 digits of content


PLAYER.UP_KEYMASK:  equ 54
PLAYER.UP_KEYADDR:  equ 55
PLAYER.DOWN_KEYMASK:equ 56
PLAYER.DOWN_KEYADDR:equ 57
PLAYER.LEFT_KEYMASK:equ 58
PLAYER.LEFT_KEYADDR:equ 59
PLAYER.RIGHT_KEYMASK:equ 60
PLAYER.RIGHT_KEYADDR:equ 61
PLAYER.FIRE_KEYMASK:equ 62
PLAYER.FIRE_KEYADDR:equ 63


; keeps separate lists of things that don't need to interact with each other to minimize walking time
; i.e. explosions and other graphical touches don't need to interact with anything
; suggest groups:
; 1 - player, player's laser fire
; 2 - enemy ships, enemy bullets
; 3 - bounty and powerups

; list of 1 walks the list of 2			(N squared!)
; player (only) walks the list of 3

; there is some opportunity to be clever and minimize the work done in the 1 - 2 interaction
; e.g. by keeping the lists sorted or partitioned.
; It's not entirely clear that this will be a gain overall considering maintenance overhead

; It will help if all the objects (at least, within a group) have some consistent formatting
; (there doesn't seem to be a requirement for the size to be power-of-2)

; 0 link
; 1 ID? (Perhaps this is implicit from one of the vectors)
; 2-3 Y/X
; 4-5 H/W
; 6-7 call every frame   IY=this (return: carry set = remove this item)
; 8-9 call on collision  IY=this, IX=that (return: carry set = remove that item and stop walking this list)

; Could keep IMP DEF data by increasing the size of the record
; - either decreases the number of items in the list
; - or makes walking slower if link contains 2 bytes or is encoded

; or keep imp def in a parallel list at +256
; e.g. inc IYh; ld a,(IY+0); dec IYh




SIZEOF.PLAYER: equ 64

                ds align 128
PLAYER_SPACE:	ds 2*SIZEOF.PLAYER
PLAYER2_SPACE: equ PLAYER_SPACE+SIZEOF.PLAYER
