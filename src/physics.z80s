	include "tile_properties.z80s"

ds align 256
DrawTile_LookupT:
J: equ FOR 12
 I: equ FOR 16
 	dw DRAWtiles.png_{I}_{J}
 	db DRAWtiles.png_{I}_{J}PAGE | 32
 	db tile_properties_{I+(16*J)}
 NEXT I
NEXT J



    

BEGIN_SCREEN:	
print "BEGIN_SCREEN", $
				; hl points to level map data

                ld sp, HMEM_STACK_FRAME

				ld de, 0
				ld (FRAMEVECTOR),de


				ld a,BORDERSCREENOFF
				out (border),a

				ei
					
				ld ix, drawtiles_loopreturn
				
				ld a,(hl)
				inc l
;				ld (current_level_width),a
				ld a,(hl)
				inc l
; there's less of a case that this is useful				ld (current_level_height),a
				ld e,(hl)
				inc l
				ld d,(hl)
				inc l
				ld (current_level_offset),de

				ld a,(hl)
				inc l
				ld (PLAYER_SPACE + PLAYER.y),a
				ld a,(hl)
				inc l
				ld (PLAYER_SPACE + PLAYER.x),a
				xor a
				ld (PLAYER_SPACE + PLAYER.yl),a
				ld (PLAYER_SPACE + PLAYER.xl),a
				
current_level_offset: equ $+1
				ld hl,(0000)
							

				ld e,3
tiledraw_loop_buffer:
				ld a,e
				dec a
				rla
				add SCREENPAGE0
				out (hmpr),a

				ld bc,0
                ld (65534),bc

				exx
				ld hl,32768
				exx
				ld c,11
tiledraw_loop_y:				

				ld b,16
tiledraw_loop_x:				
				ld a,(hl)
				
				
				exx
				
				ld c,a
				xor a
				rl c
				rla
				rl c
				rla
				add DrawTile_LookupT/256
				ld b,a
				
				ld a,(bc)
				ld e,a
				inc c
				ld a,(bc)
				ld d,a
				inc c
				ld a,(bc)
				
				jp HMEM_SWITCH_LMEM_DRAW  ; SP is background remove stack, DE is routine in page A, HL is HMEM address to draw			
drawtiles_loopreturn:
				ld a,l
				sub 128-8
				ld l,a
				exx
				inc hl
				djnz tiledraw_loop_x
				
				exx
				ld l,0
				ld a,h
				add 8
				ld h,a
				exx
				dec c
				jr nz, tiledraw_loop_y

				ld a,l
				sub 16*11
				ld l,a
				ld a,h
				sbc 0
				ld h,a

				dec e
				jr nz, tiledraw_loop_buffer		

			  ; draw the whole screen three times
              ; don't call DUPLICATESCREENDATA, it disables interrupts (and has long LDIRs anyway) which will disrupt music
                
                
                
                
                
; then loop again to fill in the physics tables
; (shame not to put this in the other loop, but we don't need to execute it three times)                
                
                ld de, BLOCK_COLLISION_TABLE
                
                exx
                ld b, 16*11
setup_COLLISION_TABLE_loop:
                exx
                
 				ld c,(hl)
 				inc l
				xor a
				scf
				rl c
				rla
				scf
				rl c
				rla
				add DrawTile_LookupT/256
				ld b,a
               
                ld a,(bc)
                ld (de),a
                inc e
                
                exx
                djnz setup_COLLISION_TABLE_loop
                
                
                
                
                
                
                
                
				ld hl, GAMEPHYSICS_INTCALLBACK
				ld (FRAMEVECTOR),hl

				ld a,SCREENPAGE0
				out (hmpr),a

				ld a,BORDERSCREENON
				out (border),a

ei

                jp MAINLOOP


HORIZONTAL_IMPULSE: equ 500
VERTICAL_IMPULSE:   equ 1100
GRAVITY_IMPULSE:	equ 350

SHIP_HEIGHT: equ 16
SHIP_WIDTH: equ 24

GAMEPHYSICS_INTCALLBACK:
				ld a,(last_calculated_frame)
				inc a
				ld (last_calculated_frame),a    ; signal that we want the screen frame to update + cycle


				

				ld IX, PLAYER_SPACE

				ld l,(IX+ PLAYER.xspeed)
				ld h,(IX+ PLAYER.xspeedh)


				ld d, KEYBOARD_TABLE/256
				ld e, (IX + PLAYER.LEFT_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.LEFT_KEYmask)
				jr nz, no_left_impulse
				
				ld bc, - HORIZONTAL_IMPULSE
				add hl,bc

no_left_impulse:

				ld e, (IX + PLAYER.RIGHT_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.RIGHT_KEYmask)
				jr nz, no_right_impulse
				
				ld bc, HORIZONTAL_IMPULSE
				add hl,bc
			
no_right_impulse:

							; dampening
				sra h
				rr l
					
				
				ld (IX+ PLAYER.xspeed),l
				ld (IX+ PLAYER.xspeedh),h

				ld e,(IX+ PLAYER.xl)
				ld d,(IX+ PLAYER.x)
				
				add hl,de
				
				set 0,l	; this is a bit of a hack - after moving left, divisions can never reduce speed below -1.
						; this is a fairly insignificant reduction in precision, but stops us drifting to the left 1 pixel every 5 seconds
				
				ld (IX+ PLAYER.xl),l
				ld (IX+ PLAYER.x),h




				ld l,(IX+ PLAYER.yspeed)
				ld h,(IX+ PLAYER.yspeedh)

				ld d, KEYBOARD_TABLE/256
				ld e, (IX + PLAYER.UP_KEYaddr)
				ld a,(de)
				and (IX + PLAYER.UP_KEYmask)
				jr nz, no_vertical_impulse
				
				ld bc, - VERTICAL_IMPULSE
				add hl,bc

no_vertical_impulse:

				ld bc, GRAVITY_IMPULSE
				add hl,bc
				
							; dampening
				sra h
				rr l

				ld (IX+ PLAYER.yspeed),l
				ld (IX+ PLAYER.yspeedh),h

				ld b,h

				ld e,(IX+ PLAYER.yl)
				ld d,(IX+ PLAYER.y)
				
				add hl,de
				
				bit 7,b
				jr nz, check_blocked_upwards				
				
check_blocked_downwards:				
				ld a,h
				add SHIP_HEIGHT
				and 0xf0
				ld e,a
				
				ld a,(IX+ PLAYER.x)
				ld c,a
				rra
				rra
				rra
				rra
				and 0x0f
				or e
				ld e,a
				ld d, BLOCK_COLLISION_TABLE/256
				
				ld  a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_downwards
				
				inc e
				ld a,(de)
				and  TILE_COLLIDES
				jr nz,blocked_downwards
				
				ld a,c
				and 0x0f
				sub SHIP_WIDTH-16
				jr c, not_blocked_downwards
				
				inc e
				ld a,(de)
				and  TILE_COLLIDES
				jr z,not_blocked_downwards

blocked_downwards:
				ld a,e
				and 0xf0
				sub SHIP_HEIGHT
				ld h,a
				xor a
				ld l,a
				
not_blocked_downwards:




check_blocked_upwards:
				

				

				ld a,h			; emergency screen safety
				cp 176
				jr c, +@
				ld h,176
				@:
				ld (IX+ PLAYER.yl),l
				ld (IX+ PLAYER.y),h













				
				ld e, (IX + PLAYER.x)
				ld d, (IX + PLAYER.y)
				
				bit 7,(IX + PLAYER.xspeedh)
				jr nz, ship_pointing_left
				ld bc, ship.png_0_0ID
				jr +@
ship_pointing_left:
				ld bc, ship.png_1_0ID
@:
				call ADD_SPRITE_TO_CURRENT_LIST ; bc=routine, de=location (uses HL)


				ret














best_level: db 0





PLAYER.Xl: equ 0
PLAYER.X: equ 1
PLAYER.Yl: equ 2
PLAYER.y: equ 3
PLAYER.xspeed: equ 4
PLAYER.xspeedh: equ 5
PLAYER.yspeed: equ 6
player.yspeedh: equ 7


player.next_extend0: equ 32	; 0
player.next_extend1: equ 33	; 10(00)(0)
player.next_extend2: equ 34
player.next_extend3: equ 35
player.next_extendEND: equ 36

PLAYER.SCORE0: equ 40       ; binary coded decimal omitting an implied extra zero
PLAYER.SCORE1: equ 41
PLAYER.SCORE2: equ 42
PLAYER.SCORE3: equ 43
PLAYER.SCOREEND: equ 44       ; space for a 255 end marker after 8 digits of content


PLAYER.UP_KEYMASK:  equ 54
PLAYER.UP_KEYADDR:  equ 55
PLAYER.DOWN_KEYMASK:equ 56
PLAYER.DOWN_KEYADDR:equ 57
PLAYER.LEFT_KEYMASK:equ 58
PLAYER.LEFT_KEYADDR:equ 59
PLAYER.RIGHT_KEYMASK:equ 60
PLAYER.RIGHT_KEYADDR:equ 61
PLAYER.FIRE_KEYMASK:equ 62
PLAYER.FIRE_KEYADDR:equ 63



SIZEOF.PLAYER: equ 64

                ds align 128
PLAYER_SPACE:	ds 2*SIZEOF.PLAYER
PLAYER2_SPACE: equ PLAYER_SPACE+SIZEOF.PLAYER
